From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Peridot <peridot491@protonmail.com>
Date: Thu, 19 May 2022 23:17:47 +0200
Subject: [PATCH] Implement [Nacho-0023] Optimize EntityTracker for the chunk
 updater


diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 9a30b0169ea2fd956ae229472de5e74323978299..3d4749490ff291a292cdc06e33b80332f1e5147a 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -187,6 +187,10 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         this.playerConnection.sendPacket(new PacketPlayOutCombatEvent(this.bs(), PacketPlayOutCombatEvent.EnumCombatEventType.END_COMBAT));
     }
 
+    private long chunkToLong(int chunkX, int chunkZ) {
+        return ((long) chunkX << 32L) + chunkZ - -2147483648L;
+    }
+
     public void t_() {
         // CraftBukkit start
         if (this.joining) {
@@ -263,13 +267,34 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
                     this.a(tileentity);
                 }
 
-                // Nacho start - Add generics
-                Iterator<Chunk> chunkIterator = arraylist.iterator();
+                // Nacho start - Optimize EntityTracker for the chunk updater
+                // If there are a lot of entities, we end up scanning the WHOLE list of entities multiple times
+                // Which isn't the best if we have 100 players doing that
+                // So instead of updating all entities by chunk, we update all entities at once with a hashset of chunks
+                // This means we don't have to pass over the list x chunks
+                // o(chunk * entityList) => o(entitylist)
+                /*
+                Iterator<Chunk> chunkIterator = chunkList.iterator();
                 while (chunkIterator.hasNext()) {
-                    chunk = chunkIterator.next();
-                    // Nacho end
+                    chunk = (Chunk) chunkIterator.next();
                     this.u().getTracker().a(this, chunk);
                 }
+                */
+
+                LongOpenHashSet chunkPosSet = new LongOpenHashSet(arraylist.size());
+                for (Chunk newChunk : arraylist) {
+                    chunkPosSet.add(this.chunkToLong(newChunk.locX, newChunk.locZ));
+                }
+
+                Iterator<EntityTrackerEntry> trackerEntryIterator = this.u().getTracker().getEntityTrackerEntries();
+                while (trackerEntryIterator.hasNext()) {
+                    EntityTrackerEntry entitytrackerentry = trackerEntryIterator.next();
+
+                    if (entitytrackerentry.tracker != this && chunkPosSet.contains(this.chunkToLong(entitytrackerentry.tracker.ae, entitytrackerentry.tracker.ag))) {
+                        entitytrackerentry.updatePlayer(this);
+                    }
+                }
+                // Nacho - end
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index cb72b36725927272fddfdad929b268a7b06140ac..49969dcd1207241998db9040d59be666babb1952 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -239,6 +239,10 @@ public class EntityTracker {
 
     }
 
+    public Iterator<EntityTrackerEntry> getEntityTrackerEntries() {
+        return this.c.iterator();
+    }
+
     public void a(EntityPlayer entityplayer, Chunk chunk) {
         Iterator iterator = this.c.iterator();
 
